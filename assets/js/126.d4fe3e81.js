(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{730:function(e,t,a){"use strict";a.r(t);var n=a(0),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"channels"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channels"}},[e._v("#")]),e._v(" Channels")]),e._v(" "),a("p",[e._v("Connections and clients comprise the main components of the transport layer in IBC. However, application to application communication in IBC is conducted over "),a("strong",[e._v("channels")]),e._v(", which route between an application module such as the module which handles ICS20 token transfers on one chain, and the corresponding application module on another one. These applications are namespaced by "),a("strong",[e._v("port identifiers")]),e._v(" such as 'transfer' for ICS20 token transfers.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("Note that, in the case of Interchain Accounts, there are two different port IDs for host and controller modules:")]),e._v(" "),a("p",[a("code",[e._v("icahost")]),e._v(" is the default port id that the interchain accounts host submodule binds to, whereas "),a("code",[e._v("icacontroller-")]),e._v(" is the default port prefix that the interchain accounts controller submodule binds to")])]),e._v(" "),a("p",[e._v("Contrary to the core IBC transport layer logic, which handles only verification, ordering, and all around basic packet correctness, the application layer over channels handles only the application-specific logic which interprets the packets that have been sent over the transport layer. This split between transport and application layer in IBC is similar to the split between Tendermint's consensus layer (consensus, mempool, ordering of transactions) and ABCI layer (process of those transaction bytes).")]),e._v(" "),a("p",[e._v("A connection may have any number of associated channels. However, each channel is associated with only one connection ID (which indicates which light client it is secured by) and one port ID (which indicates the application that it is connected to).")]),e._v(" "),a("p",[e._v("As previously mentioned, channels are payload agnostic. The application modules sending and receiving IBC packets decide how to interpret and act upon the incoming packet data, and use their own application logic or handlers to determine which state transitions to apply according to the data contained in each received packet.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("An "),a("strong",[e._v("ordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets are delivered exactly in the order in which they were sent")]),e._v(".\nAn "),a("strong",[e._v("unordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets can be delivered in")]),e._v(" any "),a("em",[e._v("order")]),e._v(", which may differ from the order in which they were sent.")])]),e._v(" "),a("p",[a("strong",[e._v("Establishing a Channel")])]),e._v(" "),a("p",[e._v("Similarly to how connections are established, channels are established through a four-way handshake, in which each step is initiated by a relayer:")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/ibc/images/channelhandshake.png"}})],1),e._v(" "),a("ol",[a("li",[a("p",[a("code",[e._v("ChanOpenInit")]),e._v(": sets chain A into the "),a("code",[e._v("INIT")]),e._v(" state. This calls "),a("code",[e._v("OnChanOpenInit")]),e._v(" so application A can apply the custom callback that it has set on "),a("code",[e._v("INIT")]),e._v(" (for example, to check if the port has been set correctly, the channel is indeed unordered orordered as expected, etc.). An application version is also proposed in this step.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ChanOpenTry")]),e._v(": sets chain B into the "),a("code",[e._v("TRY")]),e._v(" state. This calls "),a("code",[e._v("OnChanOpenConfirm")]),e._v(" so application B can apply its custom "),a("code",[e._v("TRY")]),e._v(" callback. Application version negotiation also happens during this step.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ChanOpenAck")]),e._v(": sets chain A into the "),a("code",[e._v("OPEN")]),e._v(" state. This calls "),a("code",[e._v("OnChanOpenAck")]),e._v(", which is implemented by the application. Application version negotiation is finalised during this step.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ChanOpenConfirm")]),e._v(": sets chain B into the "),a("code",[e._v("OPEN")]),e._v(" state, so application B can apply its "),a("code",[e._v("CONFIRM")]),e._v(" logic.")])])]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v('"Crossing Hellos" refers to a situation when both chains attempt the same handshake step at the same time.')]),e._v(" "),a("p",[e._v("If both chains submit "),a("code",[e._v("OpenInit")]),e._v(" then "),a("code",[e._v("OpenTry")]),e._v(" at same time, there should be no error. In this case, both sides will need to confirm with an "),a("code",[e._v("OpenAck")]),e._v(", and then no "),a("code",[e._v("OpenConfirm")]),e._v(" is required because both ConnectionEnds will be in state OPEN after the successful "),a("code",[e._v("OpenAck")]),e._v(".")])]),e._v(" "),a("p",[a("strong",[e._v("Example code: ChannelOpenInit")])]),e._v(" "),a("p",[e._v("You can find the implementation of "),a("code",[e._v("ChannelOpenInit")]),e._v(" in the "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/keeper/msg_server.go",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("msg_server.go")]),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("It is important to note in the following code snippet that an application module has capabilities for the requested port. An application module can only use a channel and port if the application owns the capability for that port, and the module which attempts to open a channel is granted this capability in "),a("code",[e._v("app.go")]),e._v(":")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"Ly8gQ2hhbm5lbE9wZW5Jbml0IGRlZmluZXMgYSBycGMgaGFuZGxlciBtZXRob2QgZm9yIE1zZ0NoYW5uZWxPcGVuSW5pdC4KLy8gQ2hhbm5lbE9wZW5Jbml0IHdpbGwgcGVyZm9ybSAwNC1jaGFubmVsIGNoZWNrcywgcm91dGUgdG8gdGhlIGFwcGxpY2F0aW9uCi8vIGNhbGxiYWNrLCBhbmQgd3JpdGUgYW4gT3BlbkluaXQgY2hhbm5lbCBpbnRvIHN0YXRlIHVwb24gc3VjY2Vzc2Z1bCBleGVjdXRpb24uCmZ1bmMgKGsgS2VlcGVyKSBDaGFubmVsT3BlbkluaXQoZ29DdHggY29udGV4dC5Db250ZXh0LCBtc2cgKmNoYW5uZWx0eXBlcy5Nc2dDaGFubmVsT3BlbkluaXQpICgqY2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlLCBlcnJvcikgewogIGN0eCA6PSBzZGsuVW53cmFwU0RLQ29udGV4dChnb0N0eCkKCiAgLy8gTG9va3VwIG1vZHVsZSBieSBwb3J0IGNhcGFiaWxpdHkKICBtb2R1bGUsIHBvcnRDYXAsIGVyciA6PSBrLlBvcnRLZWVwZXIuTG9va3VwTW9kdWxlQnlQb3J0KGN0eCwgbXNnLlBvcnRJZCkKICBpZiBlcnIgIT0gbmlsIHsKICAgIHJldHVybiBuaWwsIHNka2Vycm9ycy5XcmFwKGVyciwgJnF1b3Q7Y291bGQgbm90IHJldHJpZXZlIG1vZHVsZSBmcm9tIHBvcnQtaWQmcXVvdDspCiAgfQoKICAuLi4KCiAgLy8gUGVyZm9ybSAwNC1jaGFubmVsIHZlcmlmaWNhdGlvbgogIGNoYW5uZWxJRCwgY2FwLCBlcnIgOj0gay5DaGFubmVsS2VlcGVyLkNoYW5PcGVuSW5pdCgKICAgIGN0eCwgbXNnLkNoYW5uZWwuT3JkZXJpbmcsIG1zZy5DaGFubmVsLkNvbm5lY3Rpb25Ib3BzLCBtc2cuUG9ydElkLAogICAgcG9ydENhcCwgbXNnLkNoYW5uZWwuQ291bnRlcnBhcnR5LCBtc2cuQ2hhbm5lbC5WZXJzaW9uLAogICkKCiAgLi4uCgogIC8vIFBlcmZvcm0gYXBwbGljYXRpb24gbG9naWMgY2FsbGJhY2sKICBpZiBlcnIgPSBjYnMuT25DaGFuT3BlbkluaXQoY3R4LCBtc2cuQ2hhbm5lbC5PcmRlcmluZywgbXNnLkNoYW5uZWwuQ29ubmVjdGlvbkhvcHMsIG1zZy5Qb3J0SWQsIGNoYW5uZWxJRCwgY2FwLCBtc2cuQ2hhbm5lbC5Db3VudGVycGFydHksIG1zZy5DaGFubmVsLlZlcnNpb24pOyBlcnIgIT0gbmlsIHsKICAgIHJldHVybiBuaWwsIHNka2Vycm9ycy5XcmFwKGVyciwgJnF1b3Q7Y2hhbm5lbCBvcGVuIGluaXQgY2FsbGJhY2sgZmFpbGVkJnF1b3Q7KQogIH0KCiAgLy8gV3JpdGUgY2hhbm5lbCBpbnRvIHN0YXRlCiAgay5DaGFubmVsS2VlcGVyLldyaXRlT3BlbkluaXRDaGFubmVsKGN0eCwgbXNnLlBvcnRJZCwgY2hhbm5lbElELCBtc2cuQ2hhbm5lbC5PcmRlcmluZywgbXNnLkNoYW5uZWwuQ29ubmVjdGlvbkhvcHMsIG1zZy5DaGFubmVsLkNvdW50ZXJwYXJ0eSwgbXNnLkNoYW5uZWwuVmVyc2lvbikKCiAgcmV0dXJuICZhbXA7Y2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlewogICAgQ2hhbm5lbElkOiBjaGFubmVsSUQsCiAgfSwgbmlsCn0K"}}),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[a("strong",[e._v("Capabilities")])]),e._v(" "),a("p",[e._v("IBC is intended to work in execution environments where modules do not necessarily trust each other. This security is accomplished using a "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-003-dynamic-capability-store.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic capability store"),a("OutboundLink")],1),e._v(". This binding strategy prevents other modules from using a particular port or channel since those modules do not own the appropriate capability. While this background information is useful, IBC application developers should not need to modify this lower level abstraction, other than setting the capabilities appropriately in "),a("code",[e._v("app.go")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"application-packet-flow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-packet-flow"}},[e._v("#")]),e._v(" Application Packet Flow")]),e._v(" "),a("p",[e._v("As stated above, application modules communicate with each other by sending packets over IBC channels. However, IBC modules do not directly pass these messages to each other over the network. Rather, the module will commit some state reflecting the transaction execution to a precisely defined path reserved for a specific message type and a specific counterparty. For example, as part of an ICS20 token transfer, the bank module would escrow the portion of tokens to be transferred and store the proof of this escrow.")]),e._v(" "),a("p",[e._v("A relayer monitors channels for events emitted when updates have been submitted to these paths. After first submitting an "),a("code",[e._v("UpdateClient")]),e._v(" to update the sending chain light client on the destination chain, it relays the message containing the packet data along with a proof that the state transition contained in the message has been commited to the state of the sending chain. The destination chain then verifies this packet and packet commitmentment proof against the state contained in the light client.")]),e._v(" "),a("p",[e._v("Look at the "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/types/packet.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("packet definition"),a("OutboundLink")],1),e._v(" to see the packet structure:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"Ly8gTmV3UGFja2V0IGNyZWF0ZXMgYSBuZXcgUGFja2V0IGluc3RhbmNlLiBJdCBwYW5pY3MgaWYgdGhlIHByb3ZpZGVkCi8vIHBhY2tldCBkYXRhIGludGVyZmFjZSBpcyBub3QgcmVnaXN0ZXJlZC4KZnVuYyBOZXdQYWNrZXQoCiAgZGF0YSBbXWJ5dGUsCiAgc2VxdWVuY2UgdWludDY0LCBzb3VyY2VQb3J0LCBzb3VyY2VDaGFubmVsLAogIGRlc3RpbmF0aW9uUG9ydCwgZGVzdGluYXRpb25DaGFubmVsIHN0cmluZywKICB0aW1lb3V0SGVpZ2h0IGNsaWVudHR5cGVzLkhlaWdodCwgdGltZW91dFRpbWVzdGFtcCB1aW50NjQsCikgUGFja2V0IHsKICByZXR1cm4gUGFja2V0ewogICAgRGF0YTogICAgICAgICAgICAgICBkYXRhLAogICAgU2VxdWVuY2U6ICAgICAgICAgICBzZXF1ZW5jZSwKICAgIFNvdXJjZVBvcnQ6ICAgICAgICAgc291cmNlUG9ydCwKICAgIFNvdXJjZUNoYW5uZWw6ICAgICAgc291cmNlQ2hhbm5lbCwKICAgIERlc3RpbmF0aW9uUG9ydDogICAgZGVzdGluYXRpb25Qb3J0LAogICAgRGVzdGluYXRpb25DaGFubmVsOiBkZXN0aW5hdGlvbkNoYW5uZWwsCiAgICBUaW1lb3V0SGVpZ2h0OiAgICAgIHRpbWVvdXRIZWlnaHQsCiAgICBUaW1lb3V0VGltZXN0YW1wOiAgIHRpbWVvdXRUaW1lc3RhbXAsCiAgfQp9Cg=="}}),e._v(" "),a("p",[a("code",[e._v("Sequence")]),e._v(" denotes the sequence number of the packet in the channel.")]),e._v(" "),a("p",[a("code",[e._v("TimeoutTimestamp")]),e._v(" and "),a("code",[e._v("TimeoutHeight")]),e._v(" dictate the time before which the receiving module must process a packet.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/ibc/images/packetflow.png"}})],1),e._v(" "),a("p",[a("strong",[e._v("Success Case")])]),e._v(" "),a("p",[e._v("In the first step of a successful packet flow, application A will send a packet (call "),a("code",[e._v("sendPacket")]),e._v(") to application B. "),a("code",[e._v("SendPacket")]),e._v(" can be triggered by a user, but applications can also trigger this as the result of some other application logic.")]),e._v(" "),a("p",[e._v("Core IBC A commits the packet to its own state and the relayer can query this packet and send a "),a("code",[e._v("RecvPacket")]),e._v(" message to core IBC B. Core IBC handles a number of verifications, including verifying that the packet was indeed sent by chain A, that the packet came in the correct order (if it was sent over an ordered channel), that the state commitment proof is valid, etc. If this verification step is successful, core IBC routes the packet to application B.")]),e._v(" "),a("HighlightBox",{attrs:{type:"note"}},[a("p",[e._v("Core IBC is unopinionated about the actual content of the packet data, as this data is at this point just bytes. It is the responsibility of the applications on either end to marshal and unmarshal the data from and to the expected data structures on either side. This is also why application version negotiation (as previously discussed in the channel handshakes) is important, as different versions of an application may result in different expected data structures on either end of the channel and application.")])]),e._v(" "),a("p",[e._v("After receiving the packet data from core IBC, application B marshals the data blob into the expected structure and applies the relevant application logic. For example, in the case of an ICS20 token transfer this entails the minting of the received tokens on chain B to the specified receiver user account. Application B then sends an "),a("code",[e._v("Acknowledgment")]),e._v(" message to core IBC B, which again commits it to its own state so it can be queried and sent by a relayer to core IBC A.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[a("strong",[e._v("Synchronous and Asynchronous Acknowledgements")])]),e._v(" "),a("p",[e._v("Acknowledgements can either take place synchronously or asynchronously. This means that the "),a("code",[e._v("OnRecvPacket")]),e._v(" callback has a return value "),a("code",[e._v("Acknowledgement")]),e._v(" which is optional.")]),e._v(" "),a("p",[e._v("In the case of a synchronous "),a("code",[e._v("Acknowledgement")]),e._v(", the callback returns an "),a("code",[e._v("Acknowledgement")]),e._v(" at the end of the process. A relayer can query this "),a("code",[e._v("Acknowledgement")]),e._v(" packet and relay immediately after the process has finished. This is useful in cases in which application A is expecting an "),a("code",[e._v("AckPacket")]),e._v(" in order to initiate some application logic "),a("code",[e._v("OnAcknowledgePacket")]),e._v(". For example, the sending chain of an ICS20 token transfer will do nothing in the case of a successful "),a("code",[e._v("AckPacket")]),e._v(", but if an error is returned the sending chain will unescrow the previously locked tokens.")]),e._v(" "),a("p",[e._v("In the case of applications like Interchain Security, there is an asynchronous "),a("code",[e._v("Acknowledgement")]),e._v(" flow. This means that the "),a("code",[e._v("Acknowledgement")]),e._v(" is not sent as part of the return value of "),a("code",[e._v("OnRecvPacket")]),e._v(", but it is sent at some later point. IBC is designed to handle this case by allowing for "),a("code",[e._v("Acknowledgements")]),e._v(" to be committed or queried asynchronously.")]),e._v(" "),a("p",[e._v("In either case, even if there is no application specific logic to be initiated as a direct result of a received "),a("code",[e._v("Acknowledgement")]),e._v(", "),a("code",[e._v("OnAcknowledgePacket")]),e._v(" will at the very least remove the commitment proof from the store to avoid cluttering the store with old data.")])]),e._v(" "),a("p",[a("strong",[e._v("Timeout Case")])]),e._v(" "),a("p",[e._v("If a packet is time-sensitive and the timeout block height or timeout timestamp specified in the packet parameters "),a("strong",[e._v("based on chain B's time")]),e._v(" has elapsed, whatever state transitions have occured as a result of the sent packet should be reversed.")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Successful:")]),e._v(" Application A sends a packet (call "),a("code",[e._v("sendPacket")]),e._v(") to application B. This can be triggerd by a user, but applications can also act without a user. Core IBC A commits the packet to its own state, and the relayer can query this packet and send a receive message to Core IBC B. Verifications are done by Core IBC B and application B gets the packet if it is valid. Note that the applications on both ends need to marshal and unmarshal the data. Application B then sends an acknowledgment message to Core IBC B, which again commits it to its own state so it can be sent by a relayer to Core IBC A.")]),e._v(" "),a("li",[a("strong",[e._v("Unsuccessful:")]),e._v(" In second scenario, the packet is not received in time. In this case, Core IBC A receives a "),a("code",[e._v("TimeoutPacket")]),e._v(" message from the relayer and calls "),a("code",[e._v("OnTimeoutPacket")]),e._v(" on application A.")])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);