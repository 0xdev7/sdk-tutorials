(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{741:function(e,t,a){"use strict";a.r(t);var o=a(0),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"relaying-in-general"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relaying-in-general"}},[e._v("#")]),e._v(" Relaying in General")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/ibc/images/ibcoverview.png"}})],1),e._v(" "),a("p",[e._v("It is useful to briefly recap what relaying is and why it is important. IBC aims to offer blockchains a protocol to enable reliable, secure and permissionless transfer of packets of data. The protocol is agnostic with respect to the data, paving the way for application developers to develop a range of possible interchain services (fungible and non-fungible token transfers are an obvious candidate, but also arbitrary cross-chain messaging via "),a("a",{attrs:{href:"https://interchain-io.medium.com/welcome-to-the-ibc-gang-lets-talk-f469883e0ffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("Interchain accounts"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("p",[e._v("On a high level, this works as follows. A module on a source chain wants to send a packet to a destination chain. It submits a message to the source chain that stores a commitment proof on-chain and logs an event with the packet information. With this information and the proof, you can submit a message to the IBC client on the destination chain, which will verify the proof and (if successful) store a receipt on-chain and have the receiving module execute the required actions according to the packet data. The acknowledgement and timeout functionality has been discussed "),a("a",{attrs:{href:"https://TODO:insert-link-to-previous-section",target:"_blank",rel:"noopener noreferrer"}},[e._v("previously"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("There are two important considerations to make based on this flow. First, on the receiving chain, you need to verify the commitment proof on the source chain. This is why a light client is used to track the state of the counterparty chain (in an efficient way). Again, refer to a previous section to find out more. Second, blockchains cannot directly communicate with one another, so how do the proof and packet data arrive at the destination chain to continue the flow described above?")]),e._v(" "),a("p",[e._v("This is where the relayer operators come into the picture: they ensure the relaying of the packets over network infrastructure. "),a("strong",[e._v("Relayers have access to full nodes of both source and destination chains, where they can query and submit messages.")]),e._v(" They listen in on the chains they service for events that require an IBC packet to be sent. They run relayer software that enables them to rebuild the packet along with the proof and submit this to the destination chain. A similar process then happens upon storing the receipt on the destination chain, causing the acknowledgement message to be sent to the source.")]),e._v(" "),a("p",[e._v("The relayers are a crucial part of the IBC infrastructure. Remember that relaying is permissionless and trustless (the light client verification provides the trust).")]),e._v(" "),a("h2",{attrs:{id:"what-is-needed-to-relay"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-needed-to-relay"}},[e._v("#")]),e._v(" What is needed to relay?")]),e._v(" "),a("p",[e._v("Before moving on to look at specific implmentations of relayer software, understand at the general set of requirements or functionality that relayer software needs to have.")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Information about the chains")]),e._v(". A relayer will relay packets between a pair of chains, so it requires some information about these chains.")]),e._v(" "),a("li",[a("strong",[e._v("Information about the path")]),e._v(". Once you know the chains you are relaying on, the next requirement is to know which path to relay on. Remember, the IBC protocol has three main layers of abstraction: the (light) clients, connections, and channels (and ports).")]),e._v(" "),a("li",[a("strong",[e._v("A private key")]),e._v(" to an relayer operator address on all chains that we want to relay on. Remember that a relayer needs to submit IBC messages to the chains they are relaying between (Receive, Acknowledge, and Timeout), which typically require a fee. Therefore the relayer operator address needs to have funds.")]),e._v(" "),a("li",[a("strong",[e._v("Ability to query and submit messages (or transactions)")]),e._v(". As mentioned already, chains do not communicate directly between one another. It is the relayer's job to listen for events related to a packet commitment. They can do this by subscribing to these events via the Tendermint websocket, and query the proofs via the Tendermint RPC endpoint. You also have the ability to query and create through transactions: clients, connections, and channels. There are transactions to update and upgrade light clients, submit notice of misbehaviour, and which allow you to relay packets and acknowledgements or timeouts. For more detail, next you will look at the command lists for the Go and Hermes relayers.")])]),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("With the current architecture, relayers use the Tendermint RPC endpoint to query for the commitment proof, as the proofs that are required to submit IBC messages to the counterparty chain (more specifically the light client) for verification are not available via gRPC. Relayer calls can put significant pressure on the RPC endpoints of the nodes, which is one of the main bottlenecks currently in production. Because the Tendermint RPC is single-threaded, large amounts of relayer calls may cause the node to run out of sync, requiring regular resets.")])]),e._v(" "),a("h3",{attrs:{id:"configuration-file"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configuration-file"}},[e._v("#")]),e._v(" Configuration file")]),e._v(" "),a("p",[e._v("The information and parameters about the chains, paths, and the name of the relayer private key to sign the messages can generally be found in a configuration file, or "),a("em",[e._v("config")]),e._v(". You will look at template configs for the Hermes and Go relayer later, but generally config files are the place to initialize, add, or edit information required for relaying.")]),e._v(" "),a("h3",{attrs:{id:"chain-registry"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chain-registry"}},[e._v("#")]),e._v(" Chain registry")]),e._v(" "),a("p",[e._v("When you have the template for the config file of the relayer software you're using, where can you find the information that it needs? The "),a("a",{attrs:{href:"https://github.com/cosmos/chain-registry",target:"_blank",rel:"noopener noreferrer"}},[e._v("chain-registry Github repository"),a("OutboundLink")],1),e._v(" provides detailed parmeters about chains and their assets, and recently a schema was added to submit IBC data. This new addition saves you from having to look up path information or canonical channels on "),a("a",{attrs:{href:"https://www.mintscan.io/cosmos/relayers",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mintscan"),a("OutboundLink")],1),e._v(" or "),a("a",{attrs:{href:"https://mapofzones.com/?testnet=false&period=24&tableOrderBy=ibcVolume&tableOrderSort=desc",target:"_blank",rel:"noopener noreferrer"}},[e._v("Map of Zones"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("The following is an example of the IBC data between Juno and Osmosis:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"json",base64:"ewogICAgJnF1b3Q7JHNjaGVtYSZxdW90OzogJnF1b3Q7Li4vaWJjX2RhdGEuc2NoZW1hLmpzb24mcXVvdDssCiAgICAmcXVvdDtjaGFpbi0xJnF1b3Q7OiB7CiAgICAgICZxdW90O2NoYWluLW5hbWUmcXVvdDs6ICZxdW90O2p1bm8mcXVvdDssCiAgICAgICZxdW90O2NsaWVudC1pZCZxdW90OzogJnF1b3Q7MDctdGVuZGVybWludC0wJnF1b3Q7LAogICAgICAmcXVvdDtjb25uZWN0aW9uLWlkJnF1b3Q7OiAmcXVvdDtjb25uZWN0aW9uLTAmcXVvdDsKICAgIH0sCiAgICAmcXVvdDtjaGFpbi0yJnF1b3Q7OiB7CiAgICAgICZxdW90O2NoYWluLW5hbWUmcXVvdDs6ICZxdW90O29zbW9zaXMmcXVvdDssCiAgICAgICZxdW90O2NsaWVudC1pZCZxdW90OzogJnF1b3Q7MDctdGVuZGVybWludC0xNDU3JnF1b3Q7LAogICAgICAmcXVvdDtjb25uZWN0aW9uLWlkJnF1b3Q7OiAmcXVvdDtjb25uZWN0aW9uLTExNDImcXVvdDsKICAgIH0sCiAgICAmcXVvdDtjaGFubmVscyZxdW90OzogWwogICAgICB7CiAgICAgICAgJnF1b3Q7Y2hhaW4tMSZxdW90OzogewogICAgICAgICAgJnF1b3Q7Y2hhbm5lbC1pZCZxdW90OzogJnF1b3Q7Y2hhbm5lbC0wJnF1b3Q7LAogICAgICAgICAgJnF1b3Q7cG9ydC1pZCZxdW90OzogJnF1b3Q7dHJhbnNmZXImcXVvdDsKICAgICAgICB9LAogICAgICAgICZxdW90O2NoYWluLTImcXVvdDs6IHsKICAgICAgICAgICZxdW90O2NoYW5uZWwtaWQmcXVvdDs6ICZxdW90O2NoYW5uZWwtNDImcXVvdDssCiAgICAgICAgICAmcXVvdDtwb3J0LWlkJnF1b3Q7OiAmcXVvdDt0cmFuc2ZlciZxdW90OwogICAgICAgIH0sCiAgICAgICAgJnF1b3Q7b3JkZXJpbmcmcXVvdDs6ICZxdW90O3Vub3JkZXJlZCZxdW90OywKICAgICAgICAmcXVvdDt2ZXJzaW9uJnF1b3Q7OiAmcXVvdDtpY3MyMC0xJnF1b3Q7LAogICAgICAgICZxdW90O3RhZ3MmcXVvdDs6IHsKICAgICAgICAgICZxdW90O3N0YXR1cyZxdW90OzogJnF1b3Q7bGl2ZSZxdW90OywKICAgICAgICAgICZxdW90O3ByZWZlcnJlZCZxdW90OzogdHJ1ZSwKICAgICAgICAgICZxdW90O2RleCZxdW90OzogJnF1b3Q7b3Ntb3NpcyZxdW90OwogICAgICAgIH0KICAgICAgfQogICAgXQogIH0K"}}),e._v(" "),a("p",[e._v("The Go relayer has built-in functionality to fetch chain information (and soon path information) from the chain-registry. Hermes has this functionality on their roadmap. You will look at both relayers in more detail in the next sections.")]),e._v(" "),a("h1",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[e._v("#")]),e._v(" FAQ")]),e._v(" "),a("p",[e._v("Cosmos is developing fast, and minor changes can cause big problems for inexperienced users. Luckily you have the option to make direct contact with developers through the "),a("a",{attrs:{href:"https://discord.com/invite/cosmosnetwork",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos Developer Discord"),a("OutboundLink")],1),e._v(". There you can find the channel "),a("strong",[e._v("#ibc-relayer")]),e._v(" dedicated to relayers in which you can ask for help.")])],1)}),[],!1,null,null,null);t.default=n.exports}}]);